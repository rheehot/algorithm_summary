
## 최소 스패닝 트리 (Minimum Spanning Tree, MST)

---

### 스패닝 트리(Spanning Tree) 란?

* **그래프 내의 모든 정점을 포함하는 트리**
* 스패닝 트리 = 신장 트리
* 스패닝 트리는 그래프의 **최소 연결 부분 그래프** 이다.
  * 최소 연결의 의미? 간선의 수가 가장 적다.
  * N 개의 정점을 가지는 그래프의 최소 간선의 수는 N - 1 개이고, N - 1 개의 간선으로 연결되어 있으면 **필연적으로 트리 형태**가 되고 이것이 바로 **스패닝 트리** 이다.
  * **즉, 일부 간선을 선택해서 만든 트리**
* 트리 형태여야 한다는 말? 선택된 간선들이 **사이클을 이루지 않는다는 의미**이다.
* 정점들이 꼭 부모 - 자식 관계로 연결될 필요는 없다는데 유의하자.



### 스패닝 트리 (Spanning Tree) 의 특징

![image-20190501173936568](https://github.com/bestdevhyo1225/algorithm_summary/blob/master/image-20190501173936568.png?raw=true)

* (b) 는 (a) 에 표시된 올바른 스패닝 트리이다.
* (c) 에서 붉은색으로 표시된 간선들은 스패닝 트리가 아니다. **사이클이 있고, 그래프가 하나로 연결되어 있지 않기 때문이다.**
* (a) 의 그래프에서도 **여러 개의 스패닝 트리**가 있음을 쉽게 알 수 있다.
* 즉, 하나의 그래프에는 많은 스패닝 트리(신장 트리)가 존재할 수 있다.
* DFS 와 BFS 을 이용하여 그래프에서 스패닝 트리(신장 트리)를 찾을 수 있다.



### 스패닝 트리 (Spanning Tree) 의 적용 사례

* 통신 네트워크 구축

<img src="https://gmlwjd9405.github.io/images/algorithm-mst/spanning-tree-example.png" width="500px" height="250px">

* 회사 내의 모든 전화기를 **가장 적은수의 케이블** 을 사용하여 연결하고자 하는 경우

* N 개의 위치를 연결하는 통신 네트워크를 **최소의 링크(간선)**를 이용하여 구축하고자 하는 경우

  ( 최소 링크수는 N - 1개가 되기 때문에 이것은 스패닝 트리가 가능해 진다. )



### 최소 스패닝 트리 (Minimum Spanning Tree, MST) 란?

* 스패닝 트리중에서 사용된 간선들의 **가중치 합이 최소인 트리**를 찾는 문제를 최소 스패닝 트리 문제라고 한다.
* 돌려서 말하자면, 그래프의 연결성을 그대로 유지하는 **가장 저렴한 그래프**를 찾는 문제
* 중요! **각 간선의 가중치가 동일하지 않을 때 단순히 가장 적은 가중치의 간선을 사용한다고 해서 최소 비용이 얻어지는 것이 아니다.**
* MST 는 각 간선의 가중치를 고려하여 최소 비용의 스패닝 트리를 선택하는 것을 말한다.
* 즉, 네트워크(가중치를 간선에 할당한 그래프)에 있는 모든 정점들을 **가장 적은 수의 "간선" 과 "비용"**으로 연결하는 것이다. 



### 최소 스패닝 트리 (Minimum Spanning Tree, MST) 특징

* 간선의 가중치 합이 최소여야 한다.
* N 개의 정점을 가지는 그래프에 대해서는 N - 1 개의 간선만을 사용해야 한다.
* 사이클이 포함되서는 안된다.



### 최소 스패닝 트리 (Minimum Spanning Tree, MST) 의 적용 사례

* 통신망, 도로망, 유통망에서 길이나 구축비용 그리고 전송 시간등을 최소로 구축하려는 경우

<img src="https://gmlwjd9405.github.io/images/algorithm-mst/mst-example.png" width="500px" height="250px">

* 도로 건설 - 도시들을 모두 연결하면서 **도로의 길이가 최소**가 되도록 하는 문제
* 전기 회로 - 단자들을 모두 연결하면서 **전선의 길이가 최소**가 되도록 하는 문제
* 통신 - **전화선의 길이가 최소**가 되도록 전화 케이블 망을 구성하는 문제
* 배관 - 파이프를 모두 연결하면서 **파이프의 총 길이가 최소**가 되도록 하는 문제



### 최소 스패닝 트리 (Minimum Spanning Tree, MST) 구현 방법

* **크루스칼 알고리즘 (Kruskal MST Algorithm)** - 탐욕적인 방법(Greedy) 을 이용하여 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 것

> 1. 그래프의 모든 간선을 가중치의 오름차순으로 정렬한다.
> 2. 스패닝 트리에 하나씩 추가한다. 
> 3. 물론 가중치가 작다고 해서 무조건 간선을 트리에 더하는 것은 아니다. 자칫하다가는 선택한 간선들이 사이클을 이룰 수   있기 때문이다.
> 4. 따라서 결과적으로 사이클이 생기는 간선은 제외한다.
> 5. 모든 간선을 한 번씩 검사하고 난 뒤 종료한다.
>
> * **중요한 부분은 간선을 트리에 추가 했을 때 이미 추가한 간선들과 합쳐 사이클을 이루는지 여부를 판단하는 부분이**
>   **크루스칼 알고리즘의 핵심이다.** 
>
> ```c++
> #include <iostream>
> #include <algorithm>
> #include <vector>
> #include <tuple>
> using namespace std;
> // 트리를 이용해 상호 배제적 집합을 구현한다.
> // 자세한 구현은 종만북 25장 상호 배제적 집합을 참고하자.
> sturct DisjoinSet;
> const int MAX_V = 100;
> // 정점의 갯수
> int v;
> // 그래프의 인접 리스트 (연결된 정점의 번호, 간선의 가중치) 쌍을 담는다.
> vector<pair<int, int> > adj[MAX_V];
> 
> // 주어진 그래프에 대해 최소 스패닝 트리에 포함된 간선의 목록을 selected에 저장하고, 가중치의 합을 반환한다.
> int kruskal(vector<pair<int, int> >& selected) {
>   int cost = 0;
>   selected.clear();
>   // tuple(가중치, 정점1, 정점2) 의 목록을 얻는다.
>   vector<tuple<int, int, int> > edges;
>   for (int u = 0; u < V; ++u) {
>     for (int i = 0; i < adj[u].size(); ++i) {
>       int v = adj[u][i].first;	// 연결된 정점의 번호
>       int w = adj[u][i].second;	// 가중치
>       edges.push_back(make_tuple(w, u, v));
>     }
>   }
>   
>   // 가중치 순으로 정렬
>   sort(edges.begin(), edges.end());
>   
>   // 처음엔 모든 정점이 서로 분리되어 있다.
>   DisjoinSet sets(V);
>   for (int i = 0; i < edges.size(); ++i) {
>     // 간선 (u, v)를 검사한다.
>     int w, u, v;
>     tie(w, u, v) = edges[i];
>     // 이미 u와 v가 연결되어 있을 경우 무시 한다.
>     if (sets.find(u) == sets.find(v)) continue;
>     // 정점 u와 v를 합친다.
>     sets.merge(u, v);
>     selected.push_back(make_pair(u, v));
>     cost += w;
>   }
>   
>   return cost;
> }
> ```
>
> * 크루스칼 알고리즘의 시간 복잡도
>   * DisjoinSet에 대해 하는 연산은 현실적으로 상수 시간이다.
>   * 실제 트리를 만드는 for 문의 시간 복잡도는 O(|E|) 라고 봐도 좋다.
>   * 따라서 전체 시간 복잡도는 간선 목록의 정렬에 걸리는 시간 **O( |E| log |E| )** 가 전체 시간 복잡도이다.

* **프림 알고리즘 (Prim MST Algorithm)** - 다익스트라 알고리즘과 거의 같은 형태를 띠고 있는데, 비슷한 알고리즘으로 다른 문제를 어떻게 해결하는지에 중점을 둘 것

> 

---

## 참고

* [ 알고리즘 - 최소 스패닝 트리(Minimum Spanning Tree, MST)란 ](https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html)
* 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만) - 책 참고
